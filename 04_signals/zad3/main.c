#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>


void handler(int signum, siginfo_t *info, void *ucontext) {
    if(signum == SIGUSR1) {
        if(info->si_code <= 0)
            printf("Signal SIGUSR1 generated by kill, raise, abort or alarm\n");
        else
            printf("Signal SIGUSR1 generated by the system\n");
    }
    else if(signum == SIGSEGV) {
        printf("Segmentation fault occurred at the address %p\n", info->si_addr);
        exit(1);
    }
    else if(signum == SIGCHLD)
        printf("Child process exit status: %d\n", info->si_status);
}

int main(int argc, char **argv) {
    // preparing sigaction structure
    struct sigaction action;
    action.sa_sigaction = handler;
    sigemptyset(&action.sa_mask);
    action.sa_flags = SA_SIGINFO;

    // raising signal SIGUSR1
    sigaction(SIGUSR1, &action, NULL);

    // segmentation fault action
    sigaction(SIGSEGV, &action, NULL);

    // child sending exit status
    sigaction(SIGCHLD, &action, NULL);

    // raising a signal to trigger handlerUSR1 function
    raise(SIGUSR1);

    // making child process to trigger handlerCHLD function
    pid_t pid = fork();

    if(pid == 0) {
        // getting segmentation fault in child process to trigger handlerSEGV function
        int *a;
        a[3] = 2;
    }
    else{
        // waiting for exit status of child process
        wait(&pid);
    }

    return 0;
}
